********************************************************************************
*  These are the subcircuit files for the symbols in [Pwr]. They are intended to
* be idealized models of the likes found in PSIM, Matlab, OrCAD, etc, for aid in
* large scale simulation of schematics, without the penalty of speed and without
* sacrificing accuracy.
*
*							Vlad, Â©2008 - 2014
* 
********************************************************************************
*
* [CONTENTS]
*
* - The list of symbols in [Pwr], in alphabetical order:
*
* 3lvl_mod	- three-phase, three-level modulation controller
* 3ph_ACMotor	- three-phase induction motor
* 3ph_br_cm	- three-phase switching bridge, current mode
* 3ph_br_vm	- three-phase switching bridge, voltage mode
* 3ph_gen	- three-phase harmonic generator
* 3ph_SW	- three-phase to three-phase timed switch
* BrdgRect	- three-phase diode bridge rectifier
* BrdgRectThy	- three-phase thyristor bridge rectifier
* Cable		- power cable
* Disturb	- disturbance signal inducer
* HystComp	- single-phase hysteresis modulation controller
* Isense	- isolated current sensor
* RLC		- three-phase, series/parallel, RLC load
* SVHCC		- three-phase, space-vector, hysteresis current controller
* SVPWM		- three-phase, space-vector, pulse width modulation controller
* Transforms	- Clarke/Park/symmetrical components (separate .sub file)
* Vsense	- isolated voltage sensor
* sym		- symmetrical components matrix, phasor approach (separate .sub)
* WattMeter	- watt-meter
* wt		- angle generator
*
********************************************************************************
*
*	3ph_mod, HystComp, SVHCC, SVPWM - Single-/three-phase modulators
*
********************************************************************************
*
* [SYMBOL]
*
* - All inputs and control inputs are internally grounded with 1GOhm.
*
* - '_EN' is active low, therefore leaving it floating means enabled.
*
*
* [CHARACTERISTICS]
*
* - For all, inputs are floating and outputs are 1 Ohm.
*
****************************************
*
*	Hysteresis, single-phase
*
****************************************
*
* [SYMBOL]
*
* IN		= signal input;
* CMP		= feedback signal;
* Q,_Q		= complementary outputs;
* _EN		= _enable/disable pin, internally grounded with 1GOhm.
*
*
* [PARAMETERS]
*
* Vhigh,Vlow[V]	= logic levels;
* err	[V]	= error band;
* dt	[s]	= internal dead-time;
*
* - Hidden:
*
* td	[s]	= LTspice's specific delay time for A-devices;
*
*
* [NOTES]
*
* - Since for a three-phase application three similar subcircuits would have
* been needed, using the same block for a single-phase would have meant an
* unnecessary slow-down. Therefore, for a three-phase three of these are needed
* and only one for single-phase.
*
********************************
*
*		 reference
*		 |   feedback
*		 |   |	output
*		 |   |	|  complementary output
*		 |   |	|  | external error
*		 |   |	|  | |	 _enable/disable
*		 |   |	|  | |	 |
.subckt HystComp in cmp Q _Q er _EN
.param dt=1u err=0 Vhigh=1.1 Vlow=0 td=25n
AS in 1 0 0 0 0 a 0 SCHMITT vt=0 vh=0 vhigh={vhigh} vlow={vlow}
AR 2 in 0 0 0 0 b 0 SCHMITT vt=0 vh=0 vhigh={vhigh} vlow={vlow}
Be1 1 cmp V=if(err==0,v(er),err)
Be2 cmp 2 V=if(err==0,v(er),err)
ASR a b 0 0 0 4 3 0 SRFLOP vhigh=vhigh vlow=vlow trise={2*dt} tfall=0 td={td}
AQ 0 3 5 0 0 0 Q 0 AND vhigh={vhigh} vlow={vlow}
A_Q 0 4 5 0 0 0 _Q 0 AND vhigh={vhigh} vlow={vlow}
A_en _EN 0 0 0 0 5 0 0 BUF vhigh={vhigh} vlow={vlow}
Ren 0 _EN 1G
Rer 0 ER 1G
.ends HystComp
****************************************
*
*	Three-level modulation
*
****************************************
*
* [SYMBOL]
*
* in[a,b,c]	= three-phase signal input;
* TRI		= external carrier;
* _EN		= _enable/disable;
* A,B,C		= true control outputs;
* _A,_B,_C	= complementary control outputs.
*
* - 'TRI' has no effect unless f>0.
*
*
* [PARAMETERS]
*
* Vhigh,Vlow[V]	= output logic levels;
* f	[Hz]	= carrier frequency, symmetrical, set 0 for external;
* Vpk	[V]	= peak voltage level for the carrier (zero average);
* dt	[s]	= internal dead-time;
*
* - Hidden:
*
* td	[s]	= LTspice's specific delay time for A-devices;
* vh	[V]	= LTspice's specific hysteresis voltage for the comparators,
*		useful for noisy inputs, default <0>;
*
********************************
*
*		 'A' phase input
*		  |  'B' phase input
*		  |   |	 'C' phase input
*		  |   |	  |   external modulation
*		  |   |	  |   |	 phase 'A' output
*		  |   |	  |   |  |   phase 'A' complementary output
*		  |   |	  |   |  |   |	phase 'B' output
*		  |   |	  |   |	 |   |	|   phase 'B' complementary output
*		  |   |	  |   |	 |   |	|   |  phase 'C' output
*		  |   |	  |   |	 |   |	|   |  |   phase 'C' complementary output
*		  |   |	  |   |	 |   |	|   |  |   |  _enable/disable
*		  |   |	  |   |	 |   |	|   |  |   |   |
.subckt 3lvl_mod INa INb INc  1	 A  _A  B  _B  C  _C  _EN
.param vhigh=1 vlow=0 Vpk=1 f=1k dt=1u
.param td=100n vh=0 vt=0
Aia ina 1 0 0 0 4 3 0 SCHMITT td={td} vt={vt} vh={vh}
+ vhigh=vhigh vlow=vlow trise={2*dt} tfall=td
Aib inb 1 0 0 0 6 5 0 SCHMITT td={td} vt={vt} vh={vh}
+ vhigh=vhigh vlow=vlow trise={2*dt} tfall=td
Aic inc 1 0 0 0 8 7 0 SCHMITT td={td} vt={vt} vh={vh}
+ vhigh=vhigh vlow=vlow trise={2*dt} tfall=td
Aa 0 3 EN 0 0 0 A 0 AND vhigh=vhigh vlow=vlow
A_a 0 0 EN 4 0 0 _A 0 AND vhigh=vhigh vlow=vlow
Ab 0 5 EN 0 0 0 B 0 AND vhigh=vhigh vlow=vlow
A_b 0 0 EN 6 0 0 _B 0 AND vhigh=vhigh vlow=vlow
Ac 0 7 EN 0 0 0 C 0 AND vhigh=vhigh vlow=vlow
A_c 0 0 EN 8 0 0 _C 0 AND vhigh=vhigh vlow=vlow
Aen _EN 0 0 0 0 EN 0.1 0 SCHMITT td={td} vt={(Vhigh+Vlow)/2} vh=0
Rina ina 0 1G
Rinb inb 0 1G
Rinc inc 0 1G
Ren _EN 0 1G
Aosc {2*u(f)} {0.1*u(f)} 0 0 0 {2*u(f)} {u(f)} 0 SCHMITT vt=0 vh={Vpk}
+ vhigh={2*Vpk} vlow={-2*Vpk} td={td} trise={1/f**u(f)} Rout=1G
.ends 3lvl_mod
********************************************************
*
*	Space-vector hysteresis current controller
*
********************************************************
*
* [GENERAL]
*
* - Simple strategy for minimizing the switchings and the number of logic gates.
*
*	O1 O2 O3 | I1 I2 I3 | S1 S2 S3
*	-------------------------------
*	1  0  0  | 1  0  0  | 1  0  0
*	         | 1  1  0  | 1  1  0
*	         | x  x  x  | 0  0  0
*	-------------------------------
*
*
* [PARAMETERS]
*
* Vhigh,Vlow[V]	= logic levels;
* hi,ho	[V]	= inner and outer bands levels;
* dt	[s]	= internal dead-time;
*
* - Hidden:
*
* td	[s]	= LTspice's specific delay time for A-devices;
* vh	[V]	= LTspice's specific hysteresis voltage for Schmitt triggers,
*		sometimes useful for noisy inputs, default <0>;
*
********************************
*
*	      'A' phase reference
*	       |  'B' phase reference
*	       |   |  'C' phase reference
*	       |   |   |  'A' phase compare
*	       |   |   |   | 'B' phase compare
*	       |   |   |   |  |	'C' phase compare
*	       |   |   |   |  |	 | phase 'A' output
*	       |   |   |   |  |	 | |   phase 'A' complementary output
*	       |   |   |   |  |	 | |   |  phase 'B' output
*	       |   |   |   |  |	 | |   |  |   phase 'B' complementary output
*	       |   |   |   |  |	 | |   |  |   |  phase 'C' output
*	       |   |   |   |  |	 | |   |  |   |  |   phase 'C' complementary output
*	       |   |   |   |  |	 | |   |  |   |  |   |  _enable/disable
*	       |   |   |   |  |	 | |   |  |   |  |   |	 |
.subckt SVHCC ia* ib* ic* ia ib ic Sa _Sa Sb _Sb Sc _Sc _EN
.param vhigh=1 vlow=0 hi=0.5 ho=1 dt=1u td=50n
Aa1 ia* ia 0 0 0 _i1 i1 0 SCHMITT td={td} vt=0 vh={hi} vhigh=vhigh vlow=vlow
Aa2 ia* ia 0 0 0 _o1 o1 0 SCHMITT td={td} vt=0 vh={ho} vhigh=vhigh vlow=vlow
Ab1 ib* ib 0 0 0 _i2 i2 0 SCHMITT td={td} vt=0 vh={hi} vhigh=vhigh vlow=vlow
Ab2 ib* ib 0 0 0 _o2 o2 0 SCHMITT td={td} vt=0 vh={ho} vhigh=vhigh vlow=vlow
Ac1 ic* ic 0 0 0 _i3 i3 0 SCHMITT td={td} vt=0 vh={hi} vhigh=vhigh vlow=vlow
Ac2 ic* ic 0 0 0 _o3 o3 0 SCHMITT td={td} vt=0 vh={ho} vhigh=vhigh vlow=vlow
Aa11 _o2 o3 i1 _i2 i3 0 11 0 AND vhigh=vhigh vlow=vlow
Aa12 o1 _o2 i1 _i2 _i3 0 12 0 AND vhigh=vhigh vlow=vlow
Aa13 o1 _o3 i1 i2 _i3 0 13 0 AND vhigh=vhigh vlow=vlow
Ab11 o2 _o3 _i1 i2 _i3 0 21 0 AND vhigh=vhigh vlow=vlow
Ab12 _o1 o2 _i1 i2 i3 0 22 0 AND vhigh=vhigh vlow=vlow
Ab13 o1 _o3 i1 i2 _i3 0 23 0 AND vhigh=vhigh vlow=vlow
Ac11 _o1 o3 _i1 _i2 i3 0 31 0 AND vhigh=vhigh vlow=vlow
Ac12 _o2 o3 i1 _i2 i3 0 32 0 AND vhigh=vhigh vlow=vlow
Ac13 _o1 o2 _i1 i2 i3 0 33 0 AND vhigh=vhigh vlow=vlow
Aa111 0 11 12 13 0 15 14 0 OR vhigh=vhigh vlow=vlow trise={2*dt} tfall=td
Ab111 0 21 22 23 0 25 24 0 OR vhigh=vhigh vlow=vlow trise={2*dt} tfall=td
Ac111 0 31 32 33 0 35 34 0 OR vhigh=vhigh vlow=vlow trise={2*dt} tfall=td
Aao 0 14 0 EN 0 0 Sa 0 AND vhigh=vhigh vlow=vlow
Aa_o 0 EN 0 15 0 0 _Sa 0 AND vhigh=vhigh vlow=vlow
Abo 0 24 0 EN 0 0 Sb 0 AND vhigh=vhigh vlow=vlow
Ab_o 0 EN 0 25 0 0 _Sb 0 AND vhigh=vhigh vlow=vlow
Aco 0 34 0 EN 0 0 Sc 0 AND vhigh=vhigh vlow=vlow
Ac_o 0 EN 0 35 0 0 _Sc 0 AND vhigh=vhigh vlow=vlow
;Ria ia 0 1G
;Ria* ia* 0 1G
;Rib ib 0 1G
;Rib* ib* 0 1G
;Ric ic 0 1G
;Ric* ic* 0 1G
A_en _EN 0 0 0 0 EN 0 0 SCHMITT vt={(vhigh+vlow)/2} vh=0 vhigh=vhigh vlow=vlow
Ren _EN 0 1G
.ends SVHCC
********************************************************
*
*	Space-vector pulse-width modulation
*
********************************************************
*
* [GENERAL]
*
* - This is the symmetrical case, for the lowest switching harmonic content, but
* also for a simple approach in modelling.
*
*
* [PARAMETERS]
*
* Vhigh,Vlow[V]	= logic levels;
* f	[Hz]	= switching frequency;
* a,b=<-1,1>	= sign control of the inputs for internal angle generation;
* dt	[s]	= internal dead-time;
*
* - Hidden:
*
* td	[s]	= LTspice's specific delay time for A-devices;
*
*
* [NOTES]
*
* - The inputs are in quadrature, of the form sin/-cos and their amplitudes
* dictate the M, modulation factor, therefore keep <1.
*
* - The angle utilizes atan2(-v(b),-v(a)) by default, but this can be changed
* via {a} and {b}.
*
********************************
*
*	      input
*	      | quadrature input
*	      |	| phase 'A' output
*	      |	| |   phase 'A' complementary output
*	      |	| |   |  phase 'B' output
*	      |	| |   |  |   phase 'B' complementary output
*	      |	| |   |  |   |  phase 'C' output
*	      |	| |   |  |   |	|   phase 'C' complementary output
*	      |	| |   |  |   |	|   |  _enable/disable
*	      |	| |   |  |   |	|   |	|
.subckt SVPWM A B Sa _Sa Sb _Sb Sc _Sc _EN
.param fsw=5k dt=1u a=-1 b=-1 vhigh=1 vlow=0 td=25n
B_atan2 0 wt i=atan2(sgn(b)*v(b),sgn(a)*v(a))+pi Rpar=1
B_M 0 M i=hypot(v(b),v(a)) Rpar=1
B_alpha 0 alpha i=v(wt)-int(v(wt)*3/pi)*pi/3 Rpar=1
B_sector 0 sector i=limit(0,6,ceil(v(wt)*3/pi)) Rpar=1
B_t1 0 t1 i=sin(v(alpha)+2*pi/3)*v(M) Rpar=1
B_t2 0 t2 i=sin(v(alpha))*v(M) Rpar=1
B_t3 0 t0 i=(1-v(t1)-v(t2))/2 Rpar=1
B_t4 0 t0_1 i=v(t0)+v(t1) Rpar=1
B_t5 0 t0_2 i=v(t0)+v(t2) Rpar=1
B_t6 0 t0_1_2 i=v(t0)+v(t1)+v(t2) Rpar=1
B_Ta 0 s1 i=table( int(v(sector)), 0, 0, 1, v(t0), 2, v(t0_2), 3, v(t0_1_2), 4,
+ v(t0_1_2), 5, v(t0_1), 6, v(t0), 7, 0 ) Rpar=1
B_Tb 0 s2 i=table( int(v(sector)), 0, 0, 1, v(t0_1), 2, v(t0), 3, v(t0), 4,
+ v(t0_2), 5, v(t0_1_2), 6, v(t0_1_2), 7, 0 ) Rpar=1
B_Tc 0 s3 i=table( int(v(sector)), 0, 0, 1, v(t0_1_2), 2, v(t0_1_2), 3, v(t0_1), 4,
+ v(t0), 5, v(t0), 6, v(t0_2), 7, 0 ) Rpar=1
Aia 100 s1 0 0 0 12 11 0 SCHMITT td={td} vt=0 vh={vh}
+ vhigh=vhigh vlow=vlow trise={2*dt} tfall=td
Aib 100 s2 0 0 0 22 21 0 SCHMITT td={td} vt=0 vh={vh}
+ vhigh=vhigh vlow=vlow trise={2*dt} tfall=td
Aic 100 s3 0 0 0 32 31 0 SCHMITT td={td} vt=0 vh={vh}
+ vhigh=vhigh vlow=vlow trise={2*dt} tfall=td
Aa 0 11 EN 0 0 0 Sa 0 AND vhigh={vhigh} vlow={vlow}
A_a 0 0 EN 12 0 0 _Sa 0 AND vhigh={vhigh} vlow={vlow}
Ab 0 21 EN 0 0 0 Sb 0 AND vhigh={vhigh} vlow={vlow}
A_b 0 0 EN 22 0 0 _Sb 0 AND vhigh={vhigh} vlow={vlow}
Ac 0 31 EN 0 0 0 Sc 0 AND vhigh={vhigh} vlow={vlow}
A_c 0 0 EN 32 0 0 _Sc 0 AND vhigh={vhigh} vlow={vlow}
Aosc {102*u(fsw)} {101*u(fsw)} 0 0 0 {102*u(fsw)} {u(fsw)*100} 0 SCHMITT vt=0 vh=1
+ vhigh=2 vlow=-2 td={td} trise={1/fsw**u(fsw)}
Aen _EN 0 0 0 0 EN 101 0 SCHMITT td={td} vt={(Vhigh+Vlow)/2} vh=0
Ren 0 _EN 1G
.ends SVPWM
********************************************************************************
*
*			3ph_ACMotor - Induction motor
*
********************************************************************************
*
* [GENERAL]
*
* - It uses the general DQ reference frame and some approximation formulas, such
* as air-gap losses negligeable and iron losses being 3.5% of the total. Using
* the second method may yield some strange results.
*
*
* [SYMBOL]
*
* - It uses the non-isolated T-model for the transformer so the parameters are
* specified using either the direct mode (resistances and inductances), or the
* indirect mode (power, frequency, torque, etc).
*
*
* [PARAMETERS]
*
*
* - Direct mode:
*
* Lm	[H]	= magnetizing inductance;
* Lr	[H]	= rotor's leakage inductance;
* Ls	[H]	= stator's leakage inductance;
* Rf	[Ohm]	= iron losses equivalent resistance;
* Rr	[Ohm]	= rotor's resistance;
* Rs	[Ohm]	= stator's resistance.
*
* - Indirect mode (set all the above to zero):
*
* Pn	[W]	= shaft's delivered power;
* fn	[Hz]	= working frequency;
* Vn	[V]	= nominal line-to-line voltage;
* In	[A]	= nominal current, if zero then automatically calculated;
* phi	[rad]	= displacement factor;
* slip		= slip factor;
* Zp		= number of poles (2 pairs => Zp=4);
* J	[Kg*m^2]= moment of inertia, if zero, additional capacitor is needed at
*		pin 'W';
* DY=<0,1>	= delta <0> or wye <1> configuration.
*
* - Hidden:
*
* tripdv,tripdt	= LTspice's specific for behavioural sources, default 10V/1us;
* att		= attenuation, a minor tweak to ease up the calculations, should
*		not be needed.
*
*
* [CHARACTERISTICS]
*
* - .uic may be needed for the simulation command.
*
* - The back-EMF is modelled using F sources shunted by 1GOhm resistors(!).
*
********************************
*
*		   'A' phase input
*		    |'B' phase input
*		    | |'C' phase input
*		    | |	| rotation
*		    | |	| | inertia
*		    | |	| | |
.subckt 3ph_ACMotor a b c W J
.param Lm=0  Lr=0  Ls=0 Rf=0  Rr=0  Rs=0
.param Pn=100k  fn=50  Vn=400  In=0  phi=0.85  Zp=4  slip=40m
+ DY=1  J=0.1  att=1
+  prc=0.035  prcRr=0.4 prcRs=0.9  prcLs=0.3  prcLr=0.85
.param Lm_=if(Lm==0,_Lm,Lm) Ls_=if(Ls==0,_Ls,Ls) Lr_=if(Lr==0,_Lr,Lr)
.param Rf_=if(Rf==0,_Rf,Rf) Rs_=if(Rs==0,_Rs,Rs) Rr_=if(Rr==0,_Rr,Rr)
.param _In=if(In==0,Pn/sqrt(3)/Vn/phi*_DY,In)
+ _DY=if(DY==1,sqrt(3),1)
+ Zeq=Vn/_In  Req=Zeq*phi  sigma=(1-phi)/(1+phi) Re=Pn*slip/3/(1*slip)/_In**2
+ _Lm=Zeq/2/pi/fn/sqrt(sigma)  _Ls=0.3*sigma*_Lm  _Lr=_Ls*(1-slip)
+ _Rs=Re*slip*2  _Rr=_Rs*(1-slip)  _Rf=Vn/_In/prc
Cj w 0 Q=x*J
Bw 0 j I=( I(Ldm)*I(Lqr) - I(Lqm)*I(Ldr) ) tripdv={tripdv} tripdt={tripdt} Rpar={3/2*Zp*Lm_}
Ldm D 0 {Lm_} ic=0 Cpar=0 Rpar={Rf_} Rser=0
Ldr D Dr {Lr_} ic=0 Rser=0 Rpar=0 Cpar=0
Lds Ds D {Ls_} ic=0 Rser=0 Rpar=0 Cpar=0
Lqr Q Qr {Lr_} ic=0 Rser=0 Rpar=0 Cpar=0
Lqs Qs Q {Ls_} ic=0 Rser=0 Rpar=0 Cpar=0
Fa a N Lds {1/att}
Bs 0 N002 i=-v(w)*(Lr_*I(Ldr)-Lm_*I(Ldm)) tripdv={tripdv} tripdt={tripdt} Rpar=1
Bd 0 N001 i=v(w)*(Lr_*I(Lqr)-Lm_*I(Lqm)) tripdv={tripdv} tripdt={tripdt} Rpar=1
Ga 0 Ds a 0 {att*2/3/Rs_}
Rds Ds 0 {Rs_}
Gb 0 Ds 0 b {att/3/Rs_}
Gc 0 Ds 0 c {att/3/Rs_}
Gq 0 Qs b c {att/sqrt(3)/Rs_}
Rqs Qs 0 {Rs_}
Fbd b N Lds {-1/2/att}
Fbq b N Lqs {sqrt(3)/2/att}
Fcd c N Lds {-1/2/att}
Fcq c N Lqs {-sqrt(3)/2/att}
Ra a N 1Meg
Rb b N 1Meg
Rc c N 1Meg
R1 Qr 0 {Rr_}
G1 0 Qr N002 0 {sqrt(3/2)*Zp/Rr_}
R2 Dr 0 {Rr_}
G2 0 Dr N001 0 {sqrt(3/2)*Zp/Rr_}
Lqm Q 0 {Lm_} ic=0 Cpar=0 Rpar={Rf_} Rser=0
G3 0 w j 0 {1/att**2}
R3 w 0 1G
.ends 3ph_ACMotor
********************************************************************************
*
*		3ph_br_cm, 3ph_br_vm - Three-phase switching bridges
*
********************************************************************************
*
* [SYMBOL]
*
* INa,INb,INc	= control inputs, internally grounded with 1GOhm;
* _INa,_INb,_INc= complementary control inputs, internally grounded with 1GOhm;
* DC+,DC-	= DC voltage/current supply;
* A,B,C		= three-phase output.
*
*
* [PARAMETERS]
*
* Ron,Roff[Ohm]	= on-/off-state resistance;
* Vfwd	[V]	= forward voltage drop;
* Vdrev	[V]	= reverse breakdown voltage;
* Rs,Cs	[Ohm,F]	= series snubber across each device.
*
* - Hidden:
*
* vt,vh	[V]	= LTspice's SW specific threshold and hysteresis voltage.
*
*
* [CHARACTERISTICS]
*
* - Logic levels for control default to <0,1> with vt=0.5V and vh=0V. Increase
* {vh} if noise is a problem.
*
*
* [NOTES]
*
* - There's no dead-time so it should be supplied externally.
*
********************************
*
*	Voltage-mode
*
********************************
*
*		    phase 'A' control
*		    |	 phase 'A' complementary control
*		    |	 |    phase 'B' control
*		    |	 |    |	   phase 'B' complementary control
*		    |	 |    |	   |	phase 'C' control
*		    |	 |    |	   |	|    phase 'C' complementary control
*		    |	 |    |	   |	|    |	phase 'A' output
*		    |	 |    |	   |	|    |	| phase 'B' output
*		    |	 |    |	   |	|    |	| | phase 'C' output
*		    |	 |    |	   |	|    |	| | | Positive supply
*		    |	 |    |	   |	|    |	| | | |   Negative supply
*		    |	 |    |	   |	|    |	| | | |   |
.subckt 3ph_br_vm  INa _INa  INb _INb  INc _INc A B C DC+ DC-
.param Ron=50m Roff=100k Vfwd=1 Vrev=1k Rs=1k Cs=100p vt=0.5 vh=0
.model sw sw Ron={Ron*2} Roff={Roff*2} vt={vt} vh={vh}
.model dd d vfwd={Vfwd} Ron={Ron*2} Roff={Roff*2} Vrev={Vrev}
Sa A DC+ INa 0 SW
Da A DC+ Dd
Ca DC+ A {Cs} Rser={Rs}
S_a DC- A _INa 0 SW
C_a A DC- {Cs} Rser={Rs}
Sb B DC+ INb 0 SW
Cb DC+ B {Cs} Rser={Rs}
S_b DC- B _INb 0 SW
C_b B DC- {Cs} Rser={Rs}
Sc C DC+ INc 0 SW
Cc DC+ C {Cs} Rser={Rs}
S_c DC- C _INc 0 SW
C_c C DC- {Cs} Rser={Rs}
D_a DC- A Dd
Db B DC+ Dd
D_b DC- B Dd
Dc C DC+ Dd
D_c DC- C Dd
Ra INa 0 1G
Rb INb 0 1G
Rc INc 0 1G
R_a _INa 0 1G
R_b _INb 0 1G
R_c _INc 0 1G
.ends 3ph_br_vm
********************************
*
*	Current-mode
*
********************************
*
*		    phase 'A' control
*		    |	 phase 'A' complementary control
*		    |	 |    phase 'B' control
*		    |	 |    |	   phase 'B' complementary control
*		    |	 |    |	   |	phase 'C' control
*		    |	 |    |	   |	|    phase 'C' complementary control
*		    |	 |    |	   |	|    |	phase 'A' output
*		    |	 |    |	   |	|    |	| phase 'B' output
*		    |	 |    |	   |	|    |	| | phase 'C' output
*		    |	 |    |	   |	|    |	| | | Positive supply
*		    |	 |    |	   |	|    |	| | | |   Negative supply
*		    |	 |    |	   |	|    |	| | | |   |
.subckt 3ph_br_cm  INa _INa  INb _INb  INc _INc A B C DC+ DC-
.param Ron=50m Roff=100k Vfwd=1 Vrev=1k Rs=1k Cs=100p vt=0.5 vh=0
.model sw sw Ron={Ron*2} Roff={Roff*2} vt={vt} vh={vh}
.model dd d vfwd={Vfwd} Ron={Ron*2} Roff={Roff*2} Vrev={Vrev}
Sa A DC+ INa 0 SW
Da A DC+ Dd
Ca DC+ A {Cs} Rser={Rs}
S_a DC- A _INa 0 SW
C_a A DC- {Cs} Rser={Rs}
Sb B DC+ INb 0 SW
Cb DC+ B {Cs} Rser={Rs}
S_b DC- B _INb 0 SW
C_b B DC- {Cs} Rser={Rs}
Sc C DC+ INc 0 SW
Cc DC+ C {Cs} Rser={Rs}
S_c DC- C _INc 0 SW
C_c C DC- {Cs} Rser={Rs}
D_a DC- A Dd
Db B DC+ Dd
D_b DC- B Dd
Dc C DC+ Dd
D_c DC- C Dd
Ra INa 0 1G
Rb INb 0 1G
Rc INc 0 1G
R_a _INa 0 1G
R_b _INb 0 1G
R_c _INc 0 1G
.ends 3ph_br_cm
********************************************************************************
*
*		3ph_gen - Three-phase harmonic generator
*
********************************************************************************
*
* [GENERAL]
*
* - Symmetrical/asymmetrical, odd/even harmonics generator, true until 51st, can
* be voltage or current. It has general and separate amplitude, offset and phase
* setting, per harmonic divizor exponent, sinc spectrum shaping and up to three
* harmonics to be added/subtracted separate from the rest.
*
*
* [SYMBOL]
*
* 1,2,3		= outputs of the three phases.
* NUL		= the common for the Y-shaped generators;
* AM,FM,PM	= external control of amplitude, frequency ahd phase, internally
*		grounded with 1GOhm resistors.
*
* - 'NUL' can be grounded or floating, but for the latter there may be cases
* where a high-valued resistance or capacitor may be needed.
*
*
* [PARAMETERS]
*
* sym=<0,1>	= whether phases '2' and '3' should be identical to '1' or only
*		the fundamentals displaced;
* f	[Hz]	= fundamental frequency;
* amp	[V]	= general ampltiude;
* phi	[rad]	= harmonics' phase displacement (not fundamental);
* Ro	[Ohm]	= output resistance, default <1>;
* N=+/-<0:51>	= sets the highest number of harmonics;
* DC[1:3] [V]	= per-phase offset;
* A[1:3]  [V]	= per-phase p.u. amplitude;
* phi[1:3][rad]	= fundametal's per-phase displacement;
* h[1:3]	= up to three user selected harmonics to be added/subtracted if
*		present or not;
* a,b,c,d,e,p,q,
* xp,xq		= terms for the custom signum functions;
*
* - Hidden:
*
* tripdv,tripdt	= LTspice's characteristic for B-sources, default 100V/1us.
*
*
* [CHARACTERISTICS]
*
* - {N} has three possible values:
*	- positive, odd 	=> odd harmonics, only;
*	- positive, even	=> even harmonics, only;
*	- negative		=> odd+even harmonics.
*
* - External control for frequency and amplitude are available at pins 'FM' and
* 'AM' provided the corresponding parameters are set to zero: f=0, amp=0. The
* general displacement, though, is given by V(PM)+phase, where "phase" is either
* {phi} or {phi[1:3]};
*
* - {h[1:3]}, when set, will:
*	- subtract number <h[x]'s value> harmonic if present;
*	- add number  <h[x]'s value> harmonic if not present.
*  This will be done obeying the spectrum's shape.
*  E.g.: N=0, h1=100, default rest => 10mVpk
*
* - Instead of a computational-heavy inverse Fourier transformation, the signals
* have been simplified to the following formula:
*
*	s(t) = c[n] * sin(n*wt + phi)
*
*  where c[n] gets to be slightly more complicated for more flexibility:
*
*		a*sin(pi*n*b+c) + cos(pi*n*d+e)
*	c[n] = ---------------------------------
*		    pwr(p*pwr(n,xp)+q,xq)
*
* where {phi}, {a}, {b}, {c}, {d}, {e}, {p} and {q} are parameters to be set.
*
* - Ro=0 means the block will act as a current generator instead of a voltage
* one, with the {arrows} pointing towards the outputs; for sinking current set
* {amp} negative.
*
*
* [NOTES]
*
* - A few settings to achieve some known waveforms:
*
*  wave	|   N	|   a	|   b	|   c	|   d	|   e	| p | q	|   xp	|   xq
* ------+-------+-------+-------+-------+-------+-------+---+---+-------+-------
*   1	| 2n+1	|   1	|   1	|   0	|   0	|   0	| 1 | 0	|   1	|   1
*   2	| 2n+1	|   0	|   ~	|   ~	|   x	|   0	| 1 | 0	|   1	|   1
*   3	| 2n+1	|   1	|  1/x	|   0	|   0	| pi/2	| 1 | 0	|   2	|   1
*   4	| 2n+1	|   1	|  1/2	| pi/4	|   0	| pi/2	| 1 | 0	|   1	|   1
*   5	| 2n+1	|   1	|  1/x	|   0	|   0	| pi/2	| 1 | 0	|   0	|   1
*   6	| 2n+1	|   1	|   1	| -pi/x	|  1/y	|   0	| 1 | 0	|   1	|   1
*   7	|  2n	|   1	|  1/2	| -pi/2	|  1/2	|  pi	| 1 | 0	|   1	|   1
*  (~ means "don't care")
* 1 = square wave (amp=4/pi for unity);
* 2 = UPS square sine, variable width x (1<x<1.5);
* 3 = trapezoidal, fixed slope, variable amplitude x (x=2 => triangular);
* 4 = Hilbert transform of a square wave;
* 5 = alternating single (x=2) or variably spaced, alternating double (x>2) sinc
* impulses;
* 6 = two-steps square sine, x varies lower step's amplitude, y - upper step's
* width;
* 7 = sawtooth, double-period.
*
************************************************
*
*		output phase 'A'
*		| output phase 'B'
*		| | output phase 'C'
*		| | |  Y-connected null
*		| | |  |  external frequency control
*		| | |  |  |  external amplitude control
*		| | |  |  |  |	external phase control
*		| | |  |  |  |	|
.subckt 3ph_gen 1 2 3 NUL FM AM PM
.param  sym=1 f=50 amp=325 phi=0 Ro=1 N=-51
.param  dc1=0 dc2=0 dc3=0 A1=1 A2=1 A3=1
.param  h1=0 h2=0 h3=0 phi1=0 phi2=0 phi3=0
.param  a=0 b=1 c=0 d=1 e=pi p=1 q=0 xp=1 xq=1
.param tripdv=100 tripdt=1u
.func spec(x) {(a*sin(pi*x*b+c)+cos(pi*x*d+e))/(p*x**xp+q)**xq}
.func s(x,y) {sin(x*2*pi*idt(v(freq))+y)}
.func h(x,y) {if( x==0 | x>abs(N), 0, spec(x-0)*s(x-0,(v(PM)+y)*x**sym) )}
.func hx(x,y) {sgn(N+.5-x)*if(x==0,0,spec(x-0)*s(x-0,(v(PM)+y)*x**sym))}
.func par(x) {x/2==int(x/2)}
.param  off=2*pi/3
.func zi(y) {if(par(N)&N>0,0,h(3,y)+h(5,y)+h(7,y)+h(9,y)+h(11,y)+h(13,y)+h(15,y)+
+ h(17,y)+h(19,y)+h(21,y)+h(23,y)+h(25,y)+h(27,y)+h(29,y)+h(31,y)+h(33,y)+h(35,y)+
+ h(37,y)+h(39,y)+h(41,y)+h(43,y)+h(45,y)+h(47,y)+h(49,y)+h(51,y) )}
.func zp(y) {if(par(N+1)&N>0, 0, h(2,y)+h(4,y)+h(6,y)+h(8,y)+h(10,y)+h(12,y)+h(14,y)+h(16,y)+
+ h(18,y)+h(20,y)+h(22,y)+h(24,y)+h(26,y)+h(28,y)+h(30,y)+h(32,y)+h(34,y)+h(36,y)+
+ h(38,y)+h(40,y)+h(42,y)+h(44,y)+h(46,y)+h(48,y)+h(50,y) )}
.func z(y) {zp(y)+zi(y)}
Ba 0 _a i=hx(u(abs(N)),phi1)+z(phi)-hx(h1,if(h1==1,phi1,phi))-hx(h2,if(h2==1,phi1,phi))-hx(h3,if(h3==1,phi1,phi)) tripdv={tripdv} tripdt={tripdt}
Bb 0 _b i=hx(u(abs(N)),phi2-off)+z(phi-off)-hx(h1,-off+if(h1==1,phi2,phi))-hx(h2,-off+if(h2==1,phi2,phi))-hx(h3,-off+if(h3==1,phi2,phi)) tripdv={tripdv} tripdt={tripdt}
Bc 0 _c i=hx(u(abs(N)),phi3+off)+z(phi+off)-hx(h1,off+if(h1==1,phi3,phi))-hx(h2,off+if(h2==1,phi3,phi))-hx(h3,off+if(h3==1,phi3,phi)) tripdv={tripdv} tripdt={tripdt}
Bf 0 freq i=if( f==0,v(FM),f ) rpar=1
Ga nul 1 _a 0 {A1/Ro**u(Ro)}
Gb nul 2 _b 0 {A2/Ro**u(Ro)}
Gc nul 3 _c 0 {A3/Ro**u(Ro)}
IDC1 nul 1 {DC1/Ro**u(Ro)}
IDC2 nul 2 {DC2/Ro**u(Ro)}
IDC3 nul 3 {DC3/Ro**u(Ro)}
Ra _a 0 R=if(amp==0,v(am),amp)
Rb _b 0 R=if(amp==0,v(am),amp)
Rc _c 0 R=if(amp==0,v(am),amp)
Roa nul {if( Ro==0,00,1 )} {Ro**u(Ro)}
Rob nul {if( Ro==0,00,2 )} {Ro**u(Ro)}
Roc nul {if( Ro==0,00,3 )} {Ro**u(Ro)}
Rfm 0 FM 1G
Ram 0 AM 1G
Rpm 0 PM 1G
.ends 3ph_gen
********************************************************************************
*
*			3ph_SW - Three-phase switch
*
********************************************************************************
*
* [GENERAL]
*
* - It switches on/off with a period of {ON+OFF} and a pulse width of {ON}; it
* starts {ON}.
*
*
* [SYMBOL]
*
* A1,B1,C1	= first three-phase inputs;
* A2, B2, C2	= second three-phase inputs;
* A, B, C	= three-phase outputs.
*
*
* [PARAMETERS]
*
* Ron, Roff	= on/off resistances for the series switches, default 1m/1Meg;
* ON,OFF[Hz]	= duration of on- and off-time relative to the first input.
*
* - Hidden:
*
* trf		= multiplied with {min(ON,OFF)} to give the rise/fall times,
*		default 0.01.
*
********************************
*
*	       1st input, phase 'A'
*	       |  1st input, phase 'B'
*	       |  |  1st input, phase 'C'
*	       |  |  |	2nd input, phase 'A'
*	       |  |  |	|  2nd input, phase 'B'
*	       |  |  |	|  |  2nd input, phase 'C'
*	       |  |  |  |  |  |	 output, phase 'A'
*	       |  |  |	|  |  |	 | output, phase 'B'
*	       |  |  |	|  |  |	 | | output, phase 'C'
*	       |  |  |	|  |  |	 | | |
.subckt 3ph_SW A1 B1 C1 A2 B2 C2 A B C
.param Ron=1m Roff=1Meg On=1 Off=1 trf=0.01
.model sw sw(Ron={Ron} Roff={Roff} vt=0 vh=-1m)
S1 A A1 ctl 0 SW
S2 B B1 ctl 0 SW
S3 C C1 ctl 0 SW
S4 A A2 0 ctl SW
S5 B B2 0 ctl SW
S6 C C2 0 ctl SW
V1 ctl 0 pulse -1 1 {ON} {min(ON,OFF)*trf} {min(ON,OFF)*trf} {OFF} {ON+OFF+min(ON,OFF)*trf*2}
.ends 3ph_SW
********************************************************************************
*
*		BrdgRect, BrdgRectThy - Rectifying bridges
*
********************************************************************************
*
* [PARAMETERS]
*
* Ron	[Ohm]	= on-state resistance;
* Roff	[Ohm]	= off-state resistance;
* Vfwd	[V]	= conduction voltage drop;
* Vrev	[V]	= reverse break-down voltage;
* Rs,Cs	[Ohm,F]	= series snubber across each device;
* f	[Hz]	= working frequency, BrdgRectThy only;
* phi	[rad]	= phase displacement, BrdgRectThy only;
* ang	[rad]	= firing angle, BrdgRectThy only;
*
* - Hidden:
*
* td,tau[s]	= LTspice's specific parameters for A-devices, {tau} gives a
*		simplistic approach for dead-time control, BrdgRectThy only;
*
*
* [NOTES]
*
* - The series RC snubber can have any of the two elements null, but not both at
* the same time.
*
********************************
*
*	Controlled angle
*
********************************
*
* [SYMBOL]
*
* A,B,C		= three-phase, AC current, input pins;
* +,-		= DC output pins;
* S[1:3]	= external firing angle commands;
* EN		= external commands enable pin.
*
* - Control inputs are internally grounded with 1GOhm.
* - If 'EN' is grounded or floating, anything at pins 'S[1:3]' is ignored.
*
*
* [CHARACTERISTICS]
*
* - There is a minimal dead-time internally generated so, for external control,
* only the signal for the upper leg switches are needed at pins 'S[1:3]'.
*
* - If pin 'EN' is not used, internal firing angle is generated based on {f},
* {phi} and {ang}: {f} sets the working frequency, {phi} the displacement and
* {ang} the firing angle. This scheme is based on balanced/undistorted signals.
*
*
* [NOTES]
*
* - There is a hidden parameter, {tau}, which sets the rising/falling time for
* the final logic gates commanding the switches, which have a hysteresis of 0.4V
* giving some simple dead-time control.
*
********************************
*
*		     phase 'A' input
*		     | phase 'B' input
*		     | | phase 'C' input
*		     | | | Positive output
*		     | | | | Negative output
*		     | | | | | phase 'A' control
*		     | | | | | |    phase 'B' control
*		     | | | | | |    |	 phase 'C' control
*		     | | | | | |    |	 |    enable/_disable external control
*		     | | | | | |    |	 |    |
.subckt BrdgRectThy  A B C + - S[1] S[2] S[3] EN
.param Rs=1k Cs=1n Ron=50m Roff=100k Vfwd=1 Vrev=1k f=50  phi=0 ang=2.5m
+ dt=1u td=0 vh=0
.param tripdv=1 tripdt=1u
.model thy sw(Ron={Ron/2} Roff={Roff/2} vt=.5 vh={vh})
.model d d(vfwd={Vfwd} Vrev={Vrev} Ron={Ron/2} Roff={Roff/2})
S1 11 A c1 0 thy
S2 12 - c2 0 thy
S3 13 B c3 0 thy
S4 14 - c4 0 thy
S5 15 C c5 0 thy
S6 16 - c6 0 thy
D1 11 + D
D2 12 C D
D3 13 + D
D4 14 A D
D5 15 + D
D6 16 B D
Cs1 + A {Cs} Rser={Rs}
Cs4 A - {Cs} Rser={Rs}
Cs3 + B {Cs} Rser={Rs}
Cs6 B - {Cs} Rser={Rs}
Cs5 + C {Cs} Rser={Rs}
Cs2 C - {Cs} Rser={Rs}
B1 n1 0 i=if(v(EN)|v(+,A)-v(A)==0,0,if(v(+,B)-v(B)==0,-v(n5),if(v(+,C)-v(C)==0,-v(n3),sgn(sin(2*pi*f*time-ang-pi/6*inv(v(+,B)-v(B)==0|v(+,C)-v(C)==0)+phi))))) Rpar=0
B3 n3 0 i=if(v(EN)|v(+,B)-v(B)==0,0,if(v(+,A)-v(A)==0,-v(n5),if(v(+,C)-v(C)==0,-v(n1),sgn(sin(idt(2*pi*f)-ang-2*pi/3-pi/6*inv(v(+,A)-v(A)==0|v(+,C)-v(C)==0)+phi))))) Rpar=0
B5 n5 0 i=if(v(EN)|v(+,C)-v(C)==0,0,if(v(+,B)-v(B)==0,-v(n1),if(v(+,A)-v(A)==0,-v(n3),sgn(sin(idt(2*pi*f)-ang+2*pi/3-pi/6*inv(v(+,B)-v(B)==0|v(+,C)-v(C)==0)+phi))))) Rpar=0
C1 n1 0 10p Rpar=1
C3 n3 0 10p Rpar=1
C5 n5 0 10p Rpar=1
An1 0 n1 0 EN 0 1 0 0 OR
As1 0 EN 0 s[1] 0 0 4 0 AND
A14 0 1 0 4 0 c4 c1 0 OR td={td} trise={dt*2} tfall=0
An3 0 n3 0 EN 0 3 0 0 OR
As3 0 EN 0 s[2] 0 0 6 0 AND
A36 0 3 0 6 0 c6 c3 0 OR td={td} trise={dt*2} tfall=0
As5 0 EN 0 s[3] 0 0 2 0 AND
An5 0 n5 0 EN 0 5 0 0 OR
A52 0 5 0 2 0 c2 c5 0 OR td={td} trise={dt*2} tfall=0
Ren EN 0 1G
Rs[1] s[1] 0 1G
Rs[2] s[2] 0 1G
Rs[3] s[3] 0 1G
.ends BrdgRectThy
********************************
*
*	Fixed (no) angle
*
********************************
*
*		 phase 'A' input
*		 | phase 'B' input
*		 | | phase 'C' input
*		 | | | Positive output
*		 | | | | Negative output
*		 | | | | |
*		 | | | | |
*		 | | | | |
*		 | | | | |
*		 | | | | |
.subckt BrdgRect A B C + -
.param Vfwd=0.7 Vrev=1k Ron=50m Roff=100k Rs=100k Cs=0
.model d d( Ron={Ron} Roff={Roff} Vfwd={Vfwd} Vrev={Vrev} )
D1 A + D
C1 + A {Cs} Rser={Rs}
D2 B + D
C2 + B {Cs} Rser={Rs}
D3 C + D
C3 + C {Cs} Rser={Rs}
D4 - A D
C4 A - {Cs} Rser={Rs}
D5 - B D
C5 B - {Cs} Rser={Rs}
D6 - C D
C6 C - {Cs} Rser={Rs}
.ends BrdgRect
********************************************************************************
*
*			Cable - 4-wire cable
*
********************************************************************************
*
* [GENERAL]
*
* - Inside it's a PI LC low-pass with two R at the input/output. It uses some
* approximations and many simplifications but, for not so large powers, it is a
* fairly good model.
*
*
* [PARAMETERS]
*
* phi	[m]	= wire (equivalent) diameter;
* f	[Hz]	= nominal frequency;
* len	[m]	= length of cable;
* CuAl=<0,1>	= whether copper <0> or aluminium <1> wire is used;
* T	[C]	= working temperature;
* Space	[m]	= distance between the exterior of wires' insulations;
* Dins	[m]	= diameter with insulation;
* TriPlan=<0,1>	= whether the wires are disposed in triangle <0> or planar
* 		formation <1>.
* - Hidden:
*
* ratio=<0..0.5>= determines the distribution of the series resistance between
*		the ending Rs and PI's middle L: <0.5> (default) means the
*		resistances at the ends get 1/2 of the value, each, while the
*		inductance has none; <0> means L gets all the resistance while
*		the ending resistors none.
*
*
* [CHARACTERISTICS]
*
* - If not all the wires are used, ground only one of the inputs/outputs of each
* unused ones. e.g.: if the null is unused, ground one of the two empty pins and
* leave the other floating.
*
* - ratio=0.5 may prove to be faster in some .TRAN applications, but it's there
* for experimenting. 
*
********************************
.subckt Cable 11 21 31 41 10 20 30 40
.param phi=2m f=50 len=20 CuAl=2 T=27 Space=5m Dins=5m TriPlan=1 ratio=0.5
+ RparC=100*XC RparL=100*XL
.param Rdc=rho/Aw*(1+alpha*(T-20))
.param rhoCu=17.241n  rhoAl=28.264n  rho=if( CuAl==1,rhoCu,rhoAl )
.param alphaCu=3.93m  alphaAl=4.03m  alpha=if( CuAl==1,alphaCu,alphaAl )
.param Aw=pi*phi**2/4
.param Rac=Rdc*(1+ys+yp2)  Rac2=Rdc*(1+ys+yp)
.param xs=0.8u*pi*f/Rdc  ys=xs**2/(192+0.8*xs**2)
.param yp=xp**2/(192+0.8*xp**2)*(phi/_Space)**2*2.9
.param yp2=xp**2/(192+0.8*xp**2)*(phi/_Space)**2*(0.312*(phi/_Space)**2+1.18*(192+0.8*xp**2)/xp**2+0.27)
.param xp=0.8u*pi*f/Rdc
.param _Space=1.26**TriPlan*(Space+phi+Dins/2)
.param XL=2*pi*f*L  R=Rac*len  Rn=Rac2*len  C=8/(18g*log(_Dins/phi))*len
.param L=(0.05+0.2*log(2*_Space/phi))*len*1u
.param _Dins=if( Dins<=phi,phi,Dins ) XC=1/2/pi/f/C
Ra1 {u(ratio)*90+11} 11 {R*ratio**u(ratio)}
Rb1 {u(ratio)*180+21} 21 {R*ratio**u(ratio)}
Rc1 {u(ratio)*270+31} 31 {R*ratio**u(ratio)}
Rn1 41 401 {Rn*ratio**u(ratio)}
Ra2 {u(ratio)*92+10} 10 {R*ratio**u(ratio)}
Rb2 {u(ratio)*182+20} 20 {R*ratio**u(ratio)}
Rc2 {u(ratio)*272+30} 30 {Rn*ratio**u(ratio)}
Rn2 40 402 {Rn*ratio**u(ratio)}
Ca1 {u(ratio)*90+11} {u(ratio)*360+41} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
Ca2 {u(ratio)*92+10} {u(ratio)*362+40} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
Cb1 {u(ratio)*180+21} {u(ratio)*360+41} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
Cb2 {u(ratio)*182+20} {u(ratio)*362+40} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
Cc1 {u(ratio)*270+31} {u(ratio)*360+41} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
Cc2 {u(ratio)*272+30} {u(ratio)*362+40} {C/2} Rser=0 Rpar={RparC} Cpar=0 Lser=0 RLshunt=0 ic=0
La {u(ratio)*90+11} {u(ratio)*92+10} {L} Rser={R*(1-2*ratio)} Rpar={RparL} Cpar=0 ic=0
Lb {u(ratio)*180+21} {u(ratio)*182+20} {L} Rser={R*(1-2*ratio)} Rpar={RparL} Cpar=0 ic=0
Lc {u(ratio)*270+31} {u(ratio)*272+30} {L} Rser={R*(1-2*ratio)} Rpar={RparL} Cpar=0 ic=0
Ln 401 402 {L} Rser={Rn*(1-2*ratio)} Rpar={RparL} Cpar=0 ic=0
.ends Cable
********************************************************************************
*
*			Disturb - Disturbance signal
*
********************************************************************************
*
* [GENERAL]
*
* - It's a Gaussian bell modulated sine with skew factor given by a tanh(). For
* a better understanding the parameters, here's a minor helping graph (use fixed
* font, tab=8):
*
*	^	  sigma
*	|	<------>*	.........
*	|	.    *	.  *		^
*	|	.   *	.   *		|
*	|	.  *	.    *		| B
*	|	.*	.      *	|
*	|* * * *	.	 * * * *V........
*	|	delay	.			^
*	|<------------->.			| A
*	|					V
*	+------------------------------------------->
*
*
* [PARAMETERS]
*
* A		= amplitude outside the "bell";
* B		= amplitude of the bell itself;
* delay	[s]	= delay at which the peak of the bell occurs;
* sigma		= the Gaussian distribution factor, here modified to mean the
*		start of the bell's height (~1%);
* xp=<0:inf>	= the exponent of the exponent multiplier: exp[-(t/x)^(2*xp)];
* skew=<0:inf>	= the skew factor;
* f	[Hz]	= frequency of the modulated sine;
* phi	[rad]	= phase of the modulated sine;
* sq		= time's exponent for the sine;
*
*
* [CHARACTERISTICS]
*
* - If skew=0, the bell's height is given by {B}, else it is half its height,
* growing with {skew} but never reaching {B}. Also, skewing will be done around
* the delay point.
*
* - the formula for the Gaussian bell is modified such that {sigma} determines
* the distance from center (peak) to the 1% point of the skirt. E.g.: .TRAN 1,
* delay=0.5 and sigma=0.1 => V(out)@0.4s has 1% of the peak's value.
*
* - {sigma} is also proportional to {delay}, e.g. .TRAN 1m, delay=0.5m => if a
* +/-0.1ms bell width is wanted, sigma=0.1m.
*
* - {xp} sets a sharper bell shape with inflexion points around delay+/-sigma.
*
* - {sq} is a crude way of squaring/square rooting the time quantity on the sine
* function in order to give a time sweep without too much speed penalty.
* 
*
* [NOTES]
*
* - {skew} can take very large values for a visible effect to take place.
*
* - If only the bell shape is needed, set phi=pi/2 and sq=0 (skew=0).
*
* - Output resistance is {A}.
*
********************************
.subckt disturb out
.param  A=1 B=0.1 delay=0.5 sigma=0.1 xp=1 skew=0 f=10 phi=0 sq=1
B1 0 out i=1+B/A*exp( -4.60517*((time-delay)/sigma)**(2*xp) )*
+ sin(2*pi*f*time**sq+phi)*(tanh(time*skew/delay-skew)**u(skew)/2+.5) Rpar={A}
.ends disturb
********************************************************************************
*
*		Isense, Vsense - Current/voltage sensors
*
********************************************************************************
*
* [PARAMETERS]
*
* G [linear]	= gain/attenuation.
*
*
* [CHARACTERISTICS]
*
* - The input for the voltage sensor is floating.
*
* - The series resistance for the current sensor is zero.
*
* - Output resistance is 1 Ohm for both.
*
************************
*
*	Current
*
************************
.subckt Isense + - out+ out-
F1 out- out+ v1 {G}
R1 out- out+ 1
V1 + - 0
.ends Isense
************************
*
*	Voltage
*
************************
.subckt Vsense + - out+ out-
R1 out- out+ 1
G1 out- out+ + - {G}
.ends Vsense
********************************************************************************
*
*			RLC - Universal RLC load
*
********************************************************************************
*
* [GENERAL]
*
* - It's a 3-phase RLC load, configured as either star (DY=1) or delta (DY=0),
* series (SP=0) or parallel (SP=1), with (NUL=1) or without (NUL=0) null. It can
* have any combinations of powers, active (P), inductive reactive (QL) and/or
* capacitive reactive (QC).
*
* [PARAMETERS]
*
* V	[V]	= line-to-line RMS voltage;
* f	[Hz]	= working frequency;
* NUL=<0,1>	= specifies whether null is present <1> or not <0>, Y-connection
*		only;
* DY=<0,1>	= specifies whether the configuration is a delta-connection <0>,
*		or a wye-connection <1>;
* SP=<0,1>	= specifies whether it's series <0>, or parallel <1> RLC branch;
* P	[W]	= active power;
* QL	[VAr]	= inductive reactive power;
* QC	[VAr]	= capacitive reactive power;
* Rd	[Ohm]	= damping resistor;
*
*
* [CHARACTERISTICS]
*
* - "Rd" is only active when a reactive component is directly driven, e.g. the
* parallel RLC case. If Rd=0 it defaults to 1mOhm.
* 
* [NOTES]
*
* - It is possible to have any combination for the three powers, including null
* ones.
*
********************************
*
*	    phase 'A' input
*	    | phase 'B' input
*	    | |	phase 'C' input
*	    | |	| null
*	    | |	| |
.subckt RLC 1 2 3 4
.param  V=400  f=50  NUL=1  DY=1  SP=0  P=10k  QL=5k  QC=2k  Rd=1
.param   w=2*pi*f  N=if( DY==0,0,NUL )
+ m=if( DY==0,sqrt(3),1)  U=if( N, V/sqrt(3), V )
+ S=sqrt( P**2+(QL-QC)**2 )/m  I=S/U
+ Pd=Rdamp*I**2  Ud=Rdamp*I
+ Z=if( SP, U**2/S, S/I**2 )
+ R=if( P==0, 1, if( SP, U**2*m**2/P, P/I**2 ) )*3**N
+ XL=if( SP, U**2*m**2/QL, QL/I**2 )*3**N
+ XC=if( SP, U**2*m**2/QC, QC/I**2 )*3**N
+ L=if( QL,  XL/w, 1 )  C=if( QC, 1/w/XC, 1 )
.param NC11=if( ( QC>0 & DY & SP==0 ) | ( QL==0 & QC>0 & DY & SP ), 1,
+ if( ( QC>0 & DY==0 & SP==0 ) | ( QL==0 & QC>0 & DY==0 & SP ), 2, 0 ) )
.param NC10=if( ( QC>0 & DY & SP==0 & N==0 ) | ( QL==0 & QC>0 & DY & SP & N==0 ), 5,
+ if( ( QC>0 & DY & SP==0 & N ) | ( QL==0 & QC>0 & DY & SP & N ), 4,
+ if( ( QC>0 & DY==0 & SP==0 ) | ( QL==0 & QC>0 & DY==0 & SP ), 3, 0 ) ) )
.param NC22=if( ( QC>0 & SP==0 ) | ( QL==0 & QC>0 & SP ), 2, 0 )
.param NC20=if( ( QC>0 & DY & SP==0 & N==0 ) | ( QL==0 & QC>0 & DY & SP & N==0 ), 5,
+ if( ( QC>0 & DY & SP==0 & N ) | ( QL==0 & QC>0 & DY & SP & N ), 4,
+ if( ( QC>0 & DY==0 & SP==0 ) | ( QL==0 & QC>0 & DY==0 & SP ), 1, 0 ) ) )
.param NC33=if( ( QC>0 & SP==0 ) | ( QL==0 & QC>0 & SP ), 3, 0 )
.param NC30=NC20
.param NL11=if( ( QL>0 & QC>0 & DY & SP ) | ( QL>0 & QC==0 & DY ), 1,
+ if( ( QL>0 & QC>0 & DY==0 & SP ) | ( QL>0 & QC==0 & DY==0 ), 2, 0 ) )
.param NL10=if( ( QL>0 & QC==0 & DY & N==0 ), 5,
+ if( ( QL>0 & QC==0 & DY & N ), 4,
+ if( QL>0 & QC>0 & SP, 10,
+ if( QL>0 & QC==0 & DY==0, 3, 0 ) ) ) )
.param NL22=if( ( QL>0 & QC>0 & SP ) | ( QL>0 & QC==0 ), 2, 0 )
.param NL20=if( ( QL>0 & QC==0 & DY & N==0 ), 5,
+ if( ( QL>0 & QC==0 & DY & N ), 4,
+ if( QL>0 & QC>0 & SP, 20,
+ if( QL>0 & QC==0 & DY==0, 1, 0 ) ) ) )
.param NL33=if( ( QL>0 & QC>0 & SP ) | ( QL>0 & QC==0 ), 3, 0 )
.param NL30=if( ( QL>0 & QC==0 & DY & N==0 ), 5,
+ if( ( QL>0 & QC==0 & DY & N ), 4,
+ if( QL>0 & QC>0 & SP, 30,
+ if( QL>0 & QC==0 & DY==0, 1, 0 ) ) ) )
.param NR11=if( P>0 & QL==0 & QC==0 & DY, 1,
+ if( P>0 & QL==0 & QC==0 & DY==0, 2,
+ if( QL>0 & QC>0 & SP, 10, 0 ) ) )
.param NR10=if( ( P>0 & QL==0 & QC==0 & DY & N==0 ) | ( QL>0 & QC>0 & DY & SP & N==0 ), 5,
+ if( ( P>0 & QL==0 & QC==0 & DY & N ) | ( QL>0 & QC>0 & DY & SP & N ), 4,
+ if( ( P>0 & QL==0 & QC==0 & DY==0 ) | ( QL>0 & QC>0 & DY==0 & SP ), 3, 0 ) ) )
.param NR22=if( P>0 & QL==0 & QC==0, 2,
+ if( QL>0 & QC>0 & SP, 20, 0 ) )
.param NR20=if( ( P>0 & QL==0 & QC==0 & DY & N==0 ) | ( QL>0 & QC>0 & DY & SP & N==0 ), 5,
+ if( ( P>0 & QL==0 & QC==0 & DY & N ) | ( QL>0 & QC>0 & DY & SP & N ), 4,
+ if( ( P>0 & QL==0 & QC==0 & DY==0 ) | ( QL>0 & QC>0 & DY==0 & SP ), 1, 0 ) ) )
.param NR33=if( P>0 & QL==0 & QC==0, 3,
+ if( QL>0 & QC>0 & SP, 30, 0 ) )
.param NR30=NR20
.param Cs=C
.param Rs=if( P>0 & QC>0 & SP==0, R, Rdamp )
.param Ls=if( QL>0 & QC>0 & SP==0, L, 0 )
.param Rsp=if( P>0 & QL==0 & QC>0 & SP, R, 0 )
.param Lp=L
.param Rp=if( P>0 & QL>0 & SP, R, 0 )
.param Cp=if( QL>0 & QC>0 & SP, C, 0 )
.param Rps=if( P>0 & QL>0 & QC==0 & SP==0, R,
+ if( QL>0 & QC>0 & SP, 0, Rdamp ) )
.param Rdamp=if( ( P==0 & ( QL>0 | QC>0 ) & SP==0 ) |
+   ( ( QL>0 | QC>0 ) & SP ), Rd, 1m )
.param Rx= if( QL>0 & QC>0 & SP, Rdamp, R )
Ra {NR11} {NR10} {Rx}
Rb {NR22} {NR20} {Rx}
Rc {NR33} {NR30} {Rx}
La {NL11} {NL10} {Lp} Rser={Rps} Rpar={Rp} Cpar={Cp}
Lb {NL22} {NL20} {Lp} Rser={Rps} Rpar={Rp} Cpar={Cp}
Lc {NL33} {NL30} {Lp} Rser={Rps} Rpar={Rp} Cpar={Cp}
Ca {NC11} {NC10} {Cs} Rser={Rs} Lser={Ls} Rpar={Rsp} Cpar=0 RLshunt=0
Cb {NC22} {NC20} {Cs} Rser={Rs} Lser={Ls} Rpar={Rsp} Cpar=0 RLshunt=0
Cc {NC33} {NC30} {Cs} Rser={Rs} Lser={Ls} Rpar={Rsp} Cpar=0 RLshunt=0
.ends RLC
********************************************************************************
*
*				wt - Angle generator
*
********************************************************************************
*
* [GENERAL]
*
* - A more practical and space-efficient approach for grid PLL's wt.
*
*
* [PARAMETERS]
*
* f	[Hz]	= frequency;
* phi	[rad]	= phase;
*
* - Hidden:
*
* tripdt[s]	= LTspice's specific, improves the fast transitions if needed.
*
********************************
.subckt wt out
.param f=50 phi=0 tripdt=1u
B1 0 out Rpar=1 i=idtmod( 2*pi*f, phi, 2*pi ) tripdv=5 tripdt={tripdt}
.ends wt
********************************************************************************
*
*				WattMeter - Wattmeter
*
********************************************************************************
*
* [PARAMETERS]
*
* att		= attenuation to avoid slow-downs for calculations due to large
*		processed numbers;
* f	[Hz]	= working frequency;
*
* - Hidden:
*
* tripdv,tripdt,tripdt2	= LTspice's specific parameters for A-devices;
* off	[V]	= offset tweak for the clock generators;
*
*
* [CHARACTERISTICS]
*
* - The voltage sensing has floating input and the current sensing is a zero-
* resistance series voltage source.
*
* - The output resistances for pins 'V' and 'I' is Ro=att/2, for 'S' and 'P' is
* Ro=att^2/2, while for 'Q' and 'PF' is Ro=att.
* 
* [NOTES]
*
* - The hidden parameters shouldn't need tinkering but, if needed:
*	- {tripdv} and {tripdt} control the timestep for the behavioural sources
*	calculating the powers (default <100V/1us>), these can be tinkered with;
*	- {tripdt2} controls the timestep of the clock and resetting pulses and
*	it should be tighter than {tripdt} because the resetting pulses are set
*	to be very narrow for a minimal impact (default 10n);
*	- {off} is slighty more complicated: the clock is a function of sgn(Vin)
*	and the reset is sgn(Vin +/- off), so {off} should be at least 1000x
*	less than the peak input voltage, to have as little errors as possible.
*
********************************
*
*		  current sensing input
*		  |  voltage sensing positive input
*		  |  |	voltage sensing negative input
*		  |  |	|  current sensing output
*		  |  |	|  |  apparent power output
*		  |  |	|  |  |	active power
*		  |  |	|  |  |	| reactive power
*		  |  |	|  |  |	| | power factor
*		  |  |	|  |  |	| | |  RMS voltage
*		  |  |	|  |  |	| | |  | RMS current
*		  |  |	|  |  |	| | |  | |
.subckt WattMeter I+ V+ V- I- S P Q PF V I
.param att=1  f=50  tripdt=1u  tripdv=100  off=1m  tripdt2=10n
Vamper I+ I- 0
Gvolt 0 filt V+ V- {1/att}
Cf filt 0 {1/4/pi/f} Lser=0 Rpar=0 Cpar=0 RLshunt=0 ic=0 Rpar=1
Bper 0 per i=idt( 0, idt( 1,0,v(res) ), v(clk) ) tripdt={tripdt} tripdv={tripdv} rpar=1
B_per 0 _per i=idt( 0, idt( 1,0,v(_res) ), v(_clk) ) tripdt={tripdt} tripdv={tripdv} rpar=1
Bclk 0 clk i=u( ddt( sgn(v(filt)) ) ) tripdt={tripdt2} tripdv=0.4 rpar=2
B_clk 0 _clk i=u( ddt( sgn(-v(filt)) ) ) tripdt={tripdt2} tripdv=0.4 rpar=2
Bres 0 res i=u( ddt( sgn(v(filt)-off) ) ) tripdt={tripdt2} tripdv=0.4 rpar=2
B_res 0 _res i=u( ddt( sgn(-v(filt)-off) ) ) tripdt={tripdt2} tripdv=0.4 rpar=2
BV 0 V i=idt( 0, idt( i(Gvolt)**2,0,v(res) ) / v(per), v(clk) )**0.5 + idt( 0, idt( i(Gvolt)**2,0,v(_res) ) / v(_per), v(_clk) )**0.5 tripdt={tripdt} tripdv={tripdv} rpar={att/2}
BI 0 I i=idt( 0, idt( i(Vamper)**2/att**2,0,v(res) ) / v(per), v(clk) )**0.5 + idt( 0, idt( i(Vamper)**2/att**2,0,v(_res) ) / v(_per), v(_clk) )**0.5 tripdt={tripdt} tripdv={tripdv} rpar={att/2}
BS 0 S i=V(V)*V(I)/att**2 tripdt={tripdt} tripdv={tripdv} rpar={att**2}
BP 0 P i=idt( 0, idt( I(Gvolt)*I(Vamper)/att,0,v(res) ) / v(per), v(clk) ) + idt( 0, idt( I(Gvolt)*I(Vamper)/att,0,v(_res) ) / v(_per), v(_clk) ) tripdt={tripdt} tripdv={tripdv} rpar={att**2/2}
BQ 0 Q i=sqrt(V(S)**2-V(P)**2)/att tripdt={tripdt} tripdv={tripdv} rpar={att}
BPF 0 PF i=limit( 0, V(P)/V(S)/att, 1/att ) tripdt={tripdt} tripdv={tripdv} rpar={att}
.ends WattMeter
********************************************************************************
*
* [UPDATES]
*
* 2013.01.19	- Corrected 3ph_br_cm and SVHCC.
*		- Overall modifications and improvements.
* 2013.01.26	- Modified 3ph_gen's phase control: {phi[1:3]} control only the
*		fundamental and {phi} only the harmonics, while V(PM) is added
*		to the overall result.
* 2013.01.27	- Added a minor hysteresis to 3ph_SW to avoid random glitches.
*		- Minor modifications/corrections.
* 2013.02.04	- Modified the Cable model, it should now behave better under
*		distorted conditions and be slightly faster.
* 2013.06.15	- Modified all .funcs by the book.
* 2013.09.05	- Corrected dead-time for 3lvl_mod and SVHCC.
*		- Optimized number of devices for SVPWM and HystComp.
* 2014.04.11	- Added {vt} hidden parameter to 3lvl_mod.
*		- Added xq parameter to 3ph_gen.
* 2014.04.12	- Revised 3ph_SW.
*		- Rectified BrdgRectThy.
* 2014.04.13	- Removed TL494.
*
********************************************************************************
